"""
Privacy-Preserving Medical Diagnosis System
Using SMPC (Secure Multi-Party Computation) + Homomorphic Encryption
Sakarya University - Introduction to Cryptology Course Project
"""

# Importing necessary libraries
import tenseal as ts  # Homomorphic encryption library (developed by OpenMined/Microsoft)
import numpy as np    # For numerical operations and array handling
from sklearn.linear_model import LogisticRegression # A simple AI model for classification
from sklearn.datasets import load_breast_cancer     # The medical dataset (Breast Cancer Wisconsin dataset)
from sklearn.model_selection import train_test_split # To split data into training and testing sets
from sklearn.preprocessing import StandardScaler     # To normalize data (scale it to a specific range)
import time  # To measure execution time of operations
import json  # To save results in a JSON file

class PrivacyPreservingDiagnosisSystem:
    """
    This class manages the entire privacy-preserving diagnosis process.
    It simulates both the Patient (Client) and the Hospital (Server) roles within a single flow.
    """
    
    def __init__(self):
        # Initialize class variables
        self.model = None   # Variable to store the trained Logistic Regression model
        self.scaler = StandardScaler() # Scaler object to normalize data (essential for HE stability)
        self.context = None # The TenSEAL context that holds encryption keys and parameters
        self.weights = None # The learned weights (coefficients) of the model
        self.bias = None    # The learned bias (intercept) of the model
        self.poly_mod_degree = 8192  # Security parameter: Polynomial modulus degree (higher = more secure but slower)
        
    def setup_encryption(self):
        """
        Step 1: Setup Encryption Context
        Initializes the Homomorphic Encryption (HE) context using the CKKS scheme.
        CKKS is chosen because it supports operations on floating-point numbers (approximate arithmetic).
        """
        print("\n[1] Creating Encryption Context...")
        
        # Create the TenSEAL context
        self.context = ts.context(
            ts.SCHEME_TYPE.CKKS, # Scheme type: CKKS for float numbers
            # poly_modulus_degree: Determines the complexity of the polynomial. 8192 is a standard secure value.
            poly_modulus_degree=self.poly_mod_degree,
            # coeff_mod_bit_sizes: Array determining the bit sizes of the modulus chain.
            # It controls the multiplicative depth (how many multiplications can be done before noise becomes too high).
            coeff_mod_bit_sizes=[60, 40, 40, 60]
        )
        
        # global_scale: Since HE works with integers/polynomials, floats are scaled up by 2^40.
        # This determines the precision of the fractional part.
        self.context.global_scale = 2**40
        
        # Generate Galois Keys: Required for certain vector operations (like rotation), though dot product mainly uses relinearization keys (generated by default).
        self.context.generate_galois_keys()
        
        print("âœ“ Encryption ready")
        print(f"  - Security level: {self.poly_mod_degree} bit")
        return self.context
    
    def train_model(self):
        """
        Step 2: Hospital Side - Model Training
        The hospital trains an AI model using its own *plaintext* (unencrypted) historical data.
        This simulates the hospital preparing its intellectual property (the AI model).
        """
        print("\n[2] Training AI Model (Hospital Side)...")
        
        # 1. Load the Dataset: Using the built-in Breast Cancer dataset from sklearn.
        data = load_breast_cancer()
        X, y = data.data, data.target # X: Features (tumor size, etc.), y: Labels (malignant/benign)
        
        # 2. Feature Selection: We select only the first 10 features to keep the demo fast and simple.
        X = X[:, :10]
        
        # 3. Split Data: 80% for training the model, 20% for testing (simulating new patients).
        X_train, X_test, y_train, y_test = train_test_split(
            X, y, test_size=0.2, random_state=42
        )
        
        # 4. Normalization: HE libraries can overflow with large numbers. 
        # Scaling inputs to a small range (e.g., around 0) prevents this and improves model stability.
        X_train_scaled = self.scaler.fit_transform(X_train)
        X_test_scaled = self.scaler.transform(X_test)
        
        # 5. Train Model: Using Logistic Regression.
        # Logistic Regression formula: y = sigmoid(dot(weights, input) + bias)
        # The linear part (dot product + bias) is what we will compute homomorphically.
        self.model = LogisticRegression(max_iter=1000)
        self.model.fit(X_train_scaled, y_train)
        
        # Calculate and print accuracy
        train_acc = self.model.score(X_train_scaled, y_train)
        test_acc = self.model.score(X_test_scaled, y_test)
        
        print(f"âœ“ Model trained")
        print(f"  - Training accuracy: {train_acc*100:.2f}%")
        print(f"  - Test accuracy: {test_acc*100:.2f}%")
        
        # 6. Extract Model Parameters:
        # We extract the 'weights' and 'bias'. These are the secrets the hospital wants to protect,
        # but they must use them for calculation.
        self.weights = self.model.coef_[0]
        self.bias = self.model.intercept_[0]
        
        return X_test_scaled, y_test
    
    def encrypt_patient_data(self, patient_data):
        """
        Step 3: Patient Side - Data Encryption
        The patient encrypts their health data before sending it to the hospital.
        
        Args:
            patient_data: A numpy array containing the patient's features (e.g., 10 metrics).
        Returns:
            encrypted_data: A TenSEAL CKKS vector (encrypted object).
        """
        print("\n[3] Encrypting Patient Data...")
        
        start_time = time.time()
        
        # 1. Preprocessing: The patient data must be scaled using the same scaler the hospital used.
        # Note: In a real scenario, the hospital shares the scaler parameters (mean/std) publicly.
        patient_scaled = self.scaler.transform(patient_data.reshape(1, -1))[0]
        
        # 2. Encrypt: Convert the plaintext vector into a CKKS encrypted vector using the context.
        # From this point on, the data is unreadable without the secret key.
        encrypted_data = ts.ckks_vector(self.context, patient_scaled)
        
        encryption_time = time.time() - start_time
        
        print(f"âœ“ Data encrypted")
        print(f"  - Encryption time: {encryption_time:.4f} seconds")
        # .serialize() converts the object to bytes, useful for measuring transmission size.
        print(f"  - Encrypted size: ~{len(encrypted_data.serialize())} bytes")
        
        return encrypted_data
    
    def encrypted_inference(self, encrypted_data):
        """
        Step 4: Hospital Side - Secure Computation
        The hospital performs the prediction calculation on the ENCRYPTED data.
        It calculates the linear equation: z = (x1*w1 + x2*w2 + ... + xn*wn) + bias
        
        Args:
            encrypted_data: The encrypted patient vector.
        Returns:
            encrypted_result: The result of the calculation, still encrypted.
        """
        print("\n[4] Running Model on Encrypted Data...")
        print("   (Hospital cannot see the data - thanks to HE!)")
        
        start_time = time.time()
        
        # HOMOMORPHIC OPERATION:
        # The dot product calculates the weighted sum.
        # encrypted_data (Ciphertext) .dot( self.weights (Plaintext) )
        # TenSEAL supports multiplying an encrypted vector by a plain vector.
        # The result is added to the bias.
        encrypted_result = encrypted_data.dot(self.weights) + self.bias
        
        inference_time = time.time() - start_time
        
        print(f"âœ“ Model executed")
        print(f"  - Execution time: {inference_time:.4f} seconds")
        print(f"  - Model weights PROTECTED (remained hidden)")
        
        return encrypted_result
    
    def decrypt_result(self, encrypted_result):
        """
        Step 5: Patient Side - Decryption & Result
        The patient receives the encrypted result and decrypts it using their secret key.
        
        Args:
            encrypted_result: The encrypted prediction score (logit).
        Returns:
            prediction: The final probability (0 to 1) after applying Sigmoid.
        """
        print("\n[5] Decrypting Result (Patient Side)...")
        
        # 1. Decrypt: Unlock the data. The result is a list (even if it's one number), so we take [0].
        # This value 'z' can be any real number (e.g., 5.2, -3.1).
        decrypted_value = encrypted_result.decrypt()[0]
        
        # 2. Activation Function (Sigmoid):
        # Logistic Regression uses the Sigmoid function: 1 / (1 + e^-z).
        # Computing exponentials (e^-z) and division inside HE is very expensive and complex.
        # Standard practice is to compute the linear part encrypted, decrypt the result, 
        # and then apply the non-linear activation (Sigmoid) on the client side (plaintext).
        prediction = 1 / (1 + np.exp(-decrypted_value))
        
        print(f"âœ“ Result received")
        print(f"  - Risk Score: {prediction*100:.2f}%")
        
        # Thresholding: If probability > 50%, classify as Positive (High Risk).
        if prediction > 0.5:
            print(f"  - Diagnosis: HIGH RISK (Positive)")
        else:
            print(f"  - Diagnosis: LOW RISK (Negative)")
        
        return prediction
    
    def run_full_demo(self):
        """
        Runs the full demonstration workflow sequentially.
        """
        print("="*60)
        print("PRIVACY-PRESERVING MEDICAL DIAGNOSIS SYSTEM")
        print("SMPC + Homomorphic Encryption")
        print("="*60)
        
        total_start = time.time()
        
        # 1. Setup the encryption context
        self.setup_encryption()
        
        # 2. Train the hospital's model
        X_test, y_test = self.train_model()
        
        # 3. Select a random patient from the test set
        patient_idx = np.random.randint(0, len(X_test))
        patient_data = X_test[patient_idx]
        true_label = y_test[patient_idx]
        
        print(f"\n[TEST] Selected Patient #{patient_idx}")
        print(f"  - Actual Condition: {'Positive' if true_label == 1 else 'Negative'}")
        
        # 4. Patient encrypts data
        encrypted_patient = self.encrypt_patient_data(patient_data)
        
        # 5. Hospital computes prediction on encrypted data
        encrypted_prediction = self.encrypted_inference(encrypted_patient)
        
        # 6. Patient decrypts the result
        prediction = self.decrypt_result(encrypted_prediction)
        
        # Calculate total time
        total_time = time.time() - total_start
        
        # Summary output
        print("\n" + "="*60)
        print("RESULT SUMMARY")
        print("="*60)
        print(f"Total Execution Time: {total_time:.4f} seconds")
        print(f"Actual Condition: {'Positive' if true_label == 1 else 'Negative'}")
        print(f"Prediction: {'Positive' if prediction > 0.5 else 'Negative'}")
        print(f"Correct? {'âœ“ YES' if (prediction > 0.5) == true_label else 'âœ— NO'}")
        
        print("\nðŸ”’ PRIVACY GUARANTEES:")
        print("  âœ“ Hospital DID NOT SEE patient data")
        print("  âœ“ Patient DID NOT SEE model weights")
        print("  âœ“ Only the patient could read the result")
        
        return {
            'prediction': prediction,
            'true_label': true_label,
            'total_time': total_time,
            'correct': (prediction > 0.5) == true_label
        }

def main():
    """Main entry point of the script"""
    
    # Initialize the system
    system = PrivacyPreservingDiagnosisSystem()
    
    # Run the demo
    result = system.run_full_demo()
    
    # Save results to a JSON file
    # Converting numpy types to native Python types (int, float, bool) for JSON serialization
    with open('results.json', 'w', encoding='utf-8') as f:
        json.dump({
            'prediction': float(result['prediction']),
            'true_label': int(result['true_label']),
            'total_time': float(result['total_time']),
            'correct': bool(result['correct'])  # Essential conversion from numpy.bool_ to bool
        }, f, indent=2, ensure_ascii=False)
    
    print("\nâœ“ Results saved to 'results.json'")

if __name__ == "__main__":
    main()